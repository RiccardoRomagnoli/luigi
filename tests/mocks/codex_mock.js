const fs = require('fs');

function getArgValue(argv, flag) {
  const idx = argv.indexOf(flag);
  if (idx === -1) return null;
  return argv[idx + 1] ?? null;
}

function phaseFromPrompt(prompt) {
  if (!prompt) return 'UNKNOWN';
  if (prompt.includes('PHASE: PLAN')) return 'PLAN';
  if (prompt.includes('PHASE: REFINE_PLAN')) return 'REFINE_PLAN';
  if (prompt.includes('PHASE: ANSWER_EXECUTOR')) return 'ANSWER_EXECUTOR';
  if (prompt.includes('PHASE: REVIEW_CANDIDATES')) return 'REVIEW_CANDIDATES';
  if (prompt.includes('PHASE: HANDOFF')) return 'HANDOFF';
  if (prompt.includes('PHASE: REVIEW')) return 'REVIEW';
  return 'UNKNOWN';
}

function extractFirstCandidateId(prompt) {
  const m = prompt.match(/candidate_id:\s*([^\s]+)/);
  return m ? m[1] : null;
}

function extractJsonBlock(prompt, startMarker, endMarker) {
  const startIdx = prompt.indexOf(startMarker);
  if (startIdx === -1) return null;
  const afterStart = startIdx + startMarker.length;
  const endIdx = prompt.indexOf(endMarker, afterStart);
  if (endIdx === -1) return null;
  return prompt.slice(afterStart, endIdx).trim();
}

function main() {
  const argv = process.argv.slice(2);
  const subcommand = argv[0];
  if (subcommand !== 'exec') {
    console.error('codex_mock only supports: exec');
    process.exit(2);
  }

  const outputLastMessage = getArgValue(argv, '--output-last-message');
  if (!outputLastMessage) {
    console.error('Missing --output-last-message');
    process.exit(2);
  }

  const prompt = argv[argv.length - 1] || '';
  const phase = phaseFromPrompt(prompt);

  let response;

  if (phase === 'PLAN' || phase === 'REFINE_PLAN') {
    response = {
      status: 'OK',
      claude_prompt:
        [
          'You are Claude Code CLI. Implement the plan in this repository.',
          '',
          'Goal:',
          '- Fix division by zero behavior in `src/divide.js` so it throws `new Error("Division by zero")` when b===0.',
          '',
          'Constraints:',
          '- Make minimal change required.',
          '- Do not modify tests; just make them pass.',
          '',
          'Then run:',
          '- node scripts/unit_test.js',
          '- node scripts/e2e_test.js',
        ].join('\n'),
      test_commands: [
        { id: 'unit', kind: 'unit', label: null, command: ['node', 'scripts/unit_test.js'], timeout_sec: null },
        { id: 'e2e', kind: 'e2e', label: null, command: ['node', 'scripts/e2e_test.js'], timeout_sec: null },
      ],
      tasks: [
        {
          id: '1',
          title: 'Throw on division by zero',
          description:
            'Update src/divide.js so divide(a,b) throws Error("Division by zero") when b===0, preserving normal division otherwise.',
          acceptance_criteria: ['unit tests pass', 'e2e tests pass'],
          suggested_commands: ['node scripts/unit_test.js', 'node scripts/e2e_test.js'],
        },
      ],
      questions: [],
      notes: 'Mock plan generated by tests/mocks/codex_mock.js',
    };
  } else if (phase === 'REVIEW') {
    const testResultsJson = extractJsonBlock(prompt, 'Test results JSON:\n', '\n\nCode diff:');
    let allOk = false;
    if (testResultsJson) {
      try {
        const tr = JSON.parse(testResultsJson);
        const commands = Array.isArray(tr?.commands) ? tr.commands : [];
        allOk = commands.length > 0 && commands.every((c) => c?.result?.exit_code === 0);
      } catch {
        // ignore
      }
    }

    if (allOk) {
      response = {
        status: 'APPROVED',
        feedback: 'All tests passed; implementation looks good.',
        additional_tasks: [],
        confidence: 'high',
        questions: [],
        notes: null,
      };
    } else {
      response = {
        status: 'REJECTED',
        feedback: 'Tests are failing; fix the implementation until unit + E2E tests pass.',
        additional_tasks: [
          {
            id: 'fix-tests',
            title: 'Fix failing tests',
            description: 'Update implementation so all configured test commands pass.',
          },
        ],
        confidence: 'high',
        questions: [],
        notes: null,
      };
    }
  } else if (phase === 'REVIEW_CANDIDATES' || phase === 'HANDOFF') {
    const winner = extractFirstCandidateId(prompt);
    response = {
      status: 'APPROVED',
      winner_candidate_id: winner,
      summary: phase === 'HANDOFF' ? 'Handoff: approved and ready to merge.' : 'Approved best candidate.',
      feedback: 'Looks good.',
      next_prompt: null,
      questions: [],
      notes: 'Mock multi-agent reviewer decision generated by tests/mocks/codex_mock.js',
    };
  } else if (phase === 'ANSWER_EXECUTOR') {
    response = {
      status: 'ANSWER',
      answer: 'Mock answer from codex_mock: proceed with the simplest option and implement the fix as described.',
      questions: [],
      notes: 'Mock answer generated by tests/mocks/codex_mock.js',
    };
  } else {
    response = {
      status: 'REJECTED',
      feedback: 'Unknown prompt phase in codex_mock.',
      confidence: 'high',
    };
  }

  fs.writeFileSync(outputLastMessage, JSON.stringify(response, null, 2), 'utf8');
  process.exit(0);
}

main();

